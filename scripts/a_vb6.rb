# Ruyb -Ks {script}

#
#=== 分類取得
#
def GetType(path)

  dict = [["AA/test", "テスト"],
          ["AA/keka", "結果"]]
  rtn = ""

  dict.each { |d|
    if (/#{d[0]}/ =~ path)
      rtn = d[1]
      break
    end
  }

  return rtn
end

#
#=== 配列の指定要素の有無チェック
#
def IfNullReturnEmpty(ary, idx)
  if (ary.kind_of?(Array) == true)
    return ary.fetch(idx, "")
  end

  return ""
end

#
#=== ファイル一覧取得
#
def GetFiles(path)
  list = []
  Find.find(path) { |f|
    if (File.ftype(f) == "file")
      list.push(f)
    end
  }

  return list
end

#
#=== メイン処理
#

begin

  files = GetFiles(ARGV[0])

  t = Time.now.strftime("%Y%m%d%H%M%S")
  log   = File.open("log"   + t + ".txt", "a+")
  kekka = File.open("kekka" + t + ".txt", "a+")

  files.each { |f|
    txt = File.open(f, "r").read
    f = f.gsub(ARGV[0] + "/", "")

   auto_s = "-"

  if (/autogenerated|auto-generated/ =~ txt)
    auto_s = "auto-generated"
  end 

  lines = txt.split(/\n/)

  flg = false

  cnt = 0

  clstype = ""
  clsname = ""

  lines.each { |l|

    if (/\s+Class\s+([^\s]+)/ =~ l)
      clstype = "Class"
      clsname = $1
    end

    if (/\s+Interface\s+([^\s]+)/ =~ l)
      clstype = "Interface"
      clsname = $1
    end

    str = ""

    if (/\s+Sub |\s+Function / =~ l) and not(/^\s*'/ =~ l)
      tmp = []
      # 逆方向に走査
      for i in 0..100 do
        j = cnt - i
        if (((/\s*End\s*|Region/ =~ lines[j]) or (/Pulic |Protected |Private / =~ lines[j]) or (/\s+Sub |\s+Function / =~ lines[j])) and (j != cnt)) or (i == 100)
          tmp.reverse!
          str = str + "\n" + tmp.join("")
          break
        end

        if (lines[j] != nil)
          tmp.push(lines[j] + "\n")
        end
      end

      str = str.gsub(/\"/, "")
      str = str.gsub(/^\s*\'/, "'")
      str = str.gsub(/-----*/, "")
      str = str.gsub(/=====*/, "")
      str = str.gsub(/\*\*/, "")
      str = str.gsub(/^\s+/, "")
      str = str.gsub(/^\n/, "")
      str = str.gsub(/\n+/, "\n")
      str = str.gsub(/^'\n/, "")

      k = str.split(/^[^']*Sub /)

      if (k[1] != nil)
        k[1] = "Sub " + k[1]
      else
        k = str.split(/^[^']*Function /)
        if (k[k] != nil)
          k[1] = "Function " + k[1]
        end
      end

      tt = k[1].match(/Sub\s+([^\s(]+)/)
      if (tt == nil)
        tt = k[1].match(/Function\s+([^\s(]+)/)
      end

      mtdname = tt[1]
      ftmp = GetType(f).encode("SJIS") + "\t" + File.dirname(f).encode("SJIS") + "\t" + File.basename(f)
      kekka.puts ftmp + "\t" + auto_s + "\t" + clstype + "\t" + clsname + "\t" + (cnt+1).to_s + "\t" + mtdname + "\t\" + k.join("\"\t\"") + "\"\n"

      flg = true
    end

    cnt += 1
  }

  if (flg)
    log.printf("%s\t%s\n", f, "NOT_SKIP")
  else
    log.printf("%s\t%s\n", f, "SKIP_2")
  end

rescue => exc
  log.printf("%s\t%s\n", "ERRORE: " + f, exc)
ensure
  kekka.close
  log.close
end
